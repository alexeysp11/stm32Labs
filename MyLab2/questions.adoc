== Контрольные вопросы

1. Что такое POD типы данных?

Согласно [Википедии](https://en.wikipedia.org/wiki/Passive_data_structure), POD-типы данных 
- это аббревиатура от `plain old data structure` или `plain old data` (простые старые структуры 
данных, если переводить дословно). 
Также для обозначения этого понятия используют абрревиатуру PDS (т.е. `passive data structure`). 

Это термин из ибъектно-ориентированного программирования, который обозначает структуру данных, 
которая представлена только пассивным набором полей без объектно-ориентированной реализации. 
Это значит, что POD представляет собой класс (независимо от того, определен ли он с помощью 
ключевого слова `struct` или ключевого слова `class`) без конструкторов, деструкторов и 
виртуальных функций-членов. 

Виртуальная функция (virtual function) — это функция-член класса, объявленная в базовом классе 
и переопределенная в производном. Для ее объявления используется ключевое слово `virtual`.

2. Назовите все виды типов в языке С++

В языке С++ все типы данных можно поделить на 2 большие категории: 
- пользовательские (классы, структуры, объединения, перечисления, массивы, функции и указатели); 
- встроенные (`char`, `float`, `double`, `boolean`, `void`). 

3. Что такое пользовательский тип?

Пользовательским, или производным, типом называется тип данных, который был определен 
пользователем.

К числу пользовательских типов данных можно отнести классы, структуры, объединения, перечисления, 
массивы, функции и указатели. 

Классом называется такой пользовательский тип данных, который: 
1. используется и становится доступным путем создания экземпляра этого класса;
2. содержит некоторые свойства, называемые аттрибутами, и некоторый набор функций, с помощью 
которых этот класс взаимодействует с собственными аттрибутами и экземплярами. 

Синтаксис класса может быть представлен следующим образом: 
image:https://github.com/alexeysp11/stm32Labs/blob/master/MyLab2/img/ClassDeclaration.png[]

Структура - это абстрактный пользовательский тип данных, который используется для группировки 
элементов предположительно разных типов данных: 
```
struct address {
    char name[50];
    char street[100];
    char city[50];
    char state[20];
    int pin;
};
``` 

Объединения (`union`) - это пользовательский тип данных, все члены которого используют одну и 
ту же область памяти. 

Перечисления (`Enumeration` или просто `enum`) - это пользовательский тип даных тип данных, 
состоящий из набора именованных значений, называемых элементами или членами типа.

Перечисления определяются следующим образом: 
```
enum State {Working = 1, Failed = 0};
```
либо 
```
enum week { Mon, 
            Tue, 
            Wed, 
            Thur, 
            Fri, 
            Sat, 
            Sun }; 
```

4. Назовите модификаторы типов.

К числу  модификаторов:
- `signed`
- `unsigned`
- `short`

Модификаторы `signed`, `unsigned`, `long` и `short` могут применяться к целочисленным типам. 
К символам можно применять `signed` и `unsigned`. 
Тип `long` может применяться к типу `double`. 

5. Назовите правило установки размеров типов

Так как каждый бит содержит либо 0, либо 1, то 1 бит может иметь 2 возможных значения.
2 бита могут иметь 4 возможных значения, 3 бита могут иметь 8 возможных значений.

По сути, переменная с n-ным количеством бит может иметь `2^n` возможных значений. 
Поскольку байт состоит из 8 бит, то он может иметь `2^8 = 256` возможных значений.

6. Что делает оператор sizeof()?

Оператор `sizeof` - это ключевое слово, но это оператор времени компиляции, который определяет 
размер в байтах переменной или типа данных. Оператор `sizeof` может использоваться для получения 
размера классов, структур, объединений и любого другого типа данных, определяемого 
пользователем. 

Синтаксис использования `sizeof` следующий: 
```
sizeof(data type)
```

7. Что характеризует тип std::size_t

Это тип, способный представлять размер любого объекта в байтах: `size_t` - это тип, возвращаемый 
оператором `sizeof`, и он широко используется в стандартной библиотеке для представления размеров 
и количества.

8. Назовите фиксированные типы целых в библиотеке std

Начиная со стандарта С++11 в С++ выделены следующие фиксированные типы целых чисел в стандартной 
библиотеке: 
image:https://github.com/alexeysp11/stm32Labs/blob/master/MyLab2/img/FixedWidthIntegersTypeInCpp.png[]

9. Что такое псевдоним типа?

Псевдоним типа (англ. type alias) — средство языка программирования C++, введённое в синтаксис 
стандарта C++11 для повышения удобства обращения к пользовательским и встроенным типам данных.

В С++ новое имя типа можно создать двумя способами:
- определение с помощью директивы typedef, которое часто называется typedef-объявлением: 

```
typedef type alias;
```

- определение с помощью директивы using, которое называется объявлением псевдонима:

```
using alias = type;
```

10. Что такое явное и неявное преобразование типа?

Преобразование типов - это переопределение выражения, имеющего однин тип данных, таким образом, 
чтобы это выражение имело другой тип данных.

Существует явное и неявное преобразование типов. 

Неяное преобразование не нуждается в наличии каких-либо операторов для переопределения типа, 
потому что переопределение происходит автоматически. Например, следующий код вызывает 
неявное переопределение типов: 
```
short a = 2000;
int b;
b = a;
```

Иногда неявное преобразование может означать потерю точности, о чем компилятор может 
сигнализировать предупреждением. 
Этого предупреждения можно избежать с помощью явного преобразования.

Явным называется преобразование типов данных
```
short a=2000;
int b;
b = (int) a;    // c-like cast notation
b = int (a);    // functional notation 
```

11. Какие явные преобразования типов вы знаете?

12. Что делает reinterpret_cast?

13. Чем static_cast отличается от reinterpret_cast?

14. Что такое ОЗУ и ПЗУ?

15. Каков размер памяти ARM Cortex микроконтроллеров.

16. По какой архитектуре разработан ARM Cortex микроконтроллер?

17. В чем отличие Гарвардской архитектуры от Архитектура ФонНеймана?

18. Где располагаются локальные переменные?

19. Где располагаются статические переменные?

20. Где располагаются глобальные переменные?

21. Что такое стек?

Стек - это абстрактный тип данных, который содержит в себе некоторый набор элементов. 

Для наглядного запоминания того, что такое стек, можно представлять себе стопку книг: 
image:https://github.com/alexeysp11/stm32Labs/blob/master/MyLab2/img/WhatIsStack.png[]

Как и со стопкой книг, со стеком можно 
- push, который добавляет элемент в коллекцию (т.е. положить книгу наверх стопки),
- pop, который удаляет последний добавленный элемент, который еще не был удален (т.е. взять из 
стопки самую верхнюю книгу), 
- peek, который позволяет предоставить доступ к верхнему элементу без изменения самого стека 
(т.е. посмотреть сверхну на самую верхнюю книгу из стопки, но не брать её).

Порядок, в котором элементы выходят из стека, дает начало его альтернативному имени LIFO 
(last input, first output - последний зашёл, первый вышел).

22. Что такое указатель?

Уаказтелем называется переменная (т.е. область физической памяти), которая хранит в себе 
значение адреса другой переменной (т.е. адрес, с которого начинается область памяти для 
другой переменной). 

Указатель инициируется с помощью символа `*`, а адрес переменной можно взять с помощью `&`. 

Так, в следующем примере мы создадим переменную `variable`, присвоим ей значение 5, а затем 
создадим указатель на эту переменную `pointerOnVariable`, после чего выведем значение переменной 
и ее адрес в терминал: 
```
#include <iostream>

int main()
{
	int variable = 5; 
	int* pointerOnVariable = &variable;
	
	// Print out the value of variable 
	std::cout << "variable = " << variable << std::endl;
	std::cout << "*pointerOnVariable = " << *pointerOnVariable << std::endl;
	
	// Print out an address of the variable 
	std::cout << "&variable = " << &variable << std::endl;
	std::cout << "pointerOnVariable = " << pointerOnVariable << std::endl;
}
```

Полученный результат в терминале будет выглядеть следующим образом: 
```
variable = 5
*pointerOnVariable = 5
&variable = 0x22ff28
pointerOnVariable = 0x22ff28
```

В данном примере `*pointerOnVariable` является функцией разыменовывания указателя, т.е. 
получения значения переменной, на которую ссылается данный указатель. Аналогичный результат 
можно получить, если просто вывести значение переменной `variable`.

Поскольку указатель - это переменная, которая хранит в себе адрес на другую переменную, то, 
выведя в терминал значение указателя `pointerOnVariable`, мы выведем адрес, по которому 
находится первый бит переменной `variable`. 
Аналогично, можно взять адрес переменной напряму (т.е. без создания отдельной переменной) 
с помощью конструкции `&variable`. 

23. Что такое разыменовывание указателя?

24. Что означает взятие адреса?

25. Какие операции можно выполнять над указателями?

26. Что такое константный указатель?

27. Что такое указатель на константу?

28. Что такое ссылка? В чем её отличие от указателя?

29. Что такое регистр?

30. Что такое регистры общего назначения?

31. Что такое регистры специального назначения?

32. Как можно установить бит в регистре специального назначения?

33. Объясните как вызывается функция.

34. Что такое трансляция?

35. Что такое компоновка?

36. Как лучше организовывать структуру проекта и почему?

37. Что такое операторы?

38. Какие арифметические операторы вы знаете?

39. Какие логические операторы вы знаете?

40. Какие побитовые операторы вы знаете?

41. Приведите пример переопределения оператора

42. Какие еще операторы вы знаете?

43. Как сбросить бит с помощью битовых операторов?

44. Как установить бит с помощью битовых операторов?

45. Как поменять значение бита с помощью битовых операторов?

46. Какой микроконтроллер на отладочной плате XNUCLE ST32F411?

47. Какие блоки входят в состав микроконтроллера STM32F411?

48. В чем отличие ядра CortexM4 от CortexM3?

49. Назовите основные характеристики микроконтроллера STM32F411.

50. Назовите дополнительные характеристики микроконтроллера STM32F411.

51. Какие источники тактирования есть у микроконтроллера STM32F411

52. Назовите алгоритм подключения системной частоты к источнику тактирования микроконтроллера STM32F411.

53. Что такое ФАПЧ?

54. Что делает следующий код?

"""
int main()
{
  int StudentUdacha = 10;
  int PrepodUdachca = 0 ;

  StudentUdacha =  StudentUdacha ^ PrepodUdachca ;
  PrepodUdachca =  StudentUdacha ^ PrepodUdachca ;
  StudentUdacha ^= PrepodUdachca ;
}
"""

В данном коде мы присваиваем переменным `StudentUdacha` и `PrepodUdachca` значения 10 и 0 
соответственно. Далее в следующих трех строчках мы переопределяем эти переменные. 
