= Lab5

== Задание 

1.Подключить микроконтроллер к внешнему источнику тактирования HSE.

2.Написать программу моргания всеми 4 светодиодами на плате с периодом 0,5 с.

3.По нажатию кнопки увеличить период моргания на 0,1 с.

== Теоретический материал 

Реализовывать задержку между сменой состояния свотодиодов мы будем с помощью таймера TIM2. 
Поэтому для начала рассмотрим общий принцип работы таймера в микроконтроллерах. 

Начнем с того, что процессоры сами по себе не имеют понятия, что такое время. 
И несмотря на то, что они могут обладать функцией последовательного выполнения инструкций, 
время между этими инструкциями может быть любым (если, конечно, разработчик заранее не 
позаботится о времени). 

В мире встроенных систем время является очень важным фактором. 
Соответственно, все микроконтроллеры имеют на аппаратном уровне один или более встроенных 
таймеров, которые могут работать независимо от процессора.

В основе своей, все таймеры представляют собой счётчики импульсов: на входе получают поток
импульсов, или т.н. тактовый сигнал (англ. clock signal), а на выходе выдают "тики" 
(англ. ticks). 
Очень многое определяется количеством битов, из которых состоят счетчики таймеров: обычно 
таймеры 8-, 16- или 32-разрядные (это, кстати, упрощает чтение и запись чисел в счётчики 
с использованием стандартных 8-, 16- или 32-разрядных переменных). 

Нередко на одном микроконтроллере можно найти таймеры разного размера. 
Например, большинство AVR имеют как 8-битные, так и 16-битные таймеры, а некоторые части 
NXP Cortex M3 имеют как 16-битные, так и 32-битные таймеры. 
Отметим, что 8-битный таймер может считать `2^8 = 256` входных тактов, 16-битный таймер 
`2^16 = 65536` входных тактов и 32-битный таймер `2^32 = 4'294'967'296` (т.е. более 
4 миллиардов) входных тактов. 

После того, как число в счётчике превысило допустимое значение (это значение может быть 
выставлено в регистре ARR, Auto-Reload Register, или по переполнению регистра), таймер 
"переполняется" (т.е. обнуляет своё значение и продолжает отсчет заново). 

Этот тактовый сигнал поступит в делитель или счетчик, называемый "предварительным делителем"
(англ. prescaler). 
Выходной сигнал предделителя - это тактовый вход таймера. 
Изменяя число, на которое предделитель делит входящие тактовые импульсы, можно изменить 
частоту тактовых импульсов таймера, даже если системная тактовая частота остается прежней. 

Более высокая частота тактовых импульсов таймера позволяет реализовать более быстрое обновление 
счётчика таймера. 
Такой подход даёт высокое разрешение по времени (т.е. точность временных интервалов), но 
короткое максимальное время время действия таймера. 
В то время, как относительно низкая частота тактовых импульсов таймера даёт относительно низкое 
разрешение по времени, но большее максимальное время действия. 
То есть, если тактовая частота источника 8 МГц, а prescaler равен 8000, то за секунду на счётчик 
поступит 1000 импульсов (иными словами, значение счётчика будет увеличиваться на единицу каждую 
миллисекунду). 

При переполнении таймера он устанавливает флаг, и этот флаг можно проверить непосредственно 
в коде или использовать для генерации прерывания. 

Для того, чтобы настроить таймер, нужно установить определенные значения в следующие регистры: 
- Prescaler - то, насколько будет делиться тактовая частота (это определяет количество обновления
значения счётчика); 
- ARR - значение, до которого счётчик будет увеличивать своё значение; 
- Counter - текущее значение счётчика. 

Использованные источники: 
- https://www.embeddedrelated.com/showarticle/478.php[embeddedrelated.com]; 
- https://www.allaboutcircuits.com/technical-articles/introduction-to-microcontroller-timers-periodic-timers/[allaboutcircuits.com]
- http://microsin.net/programming/arm/an4776-general-purpose-timer-cookbook.html[microsin.net]

== Выполнение задания

В функции `main()` реализуем бесконечный цикл, в котором мы осуществим следующий порядок 
действий:
- вызываться функция задержки `delay_ms()` на некоторый промежуток времени (в нашем случае 
установим время задержки, равное 100 мс); 
- увеличим переменную `counter`, отвечающую за количество мс, прошедших с момента последнего 
события (нажатия кнопки или переключения светодиодов), на время задержки; 
- если пользователь нажал кнопку, то надо увеличить время задержки на 100 мс и обнулить 
`counter`; 
- если `counter` становится больше или равен периоду моргания, то надо переключить светодиоды. 

В функции `delay_ms()`, выполняющей задержку, реализуем следующие действия: 
- устанавливаем бит URS в регистре TIM2_CR1 в ноль, то есть прерывание только по переполнению; 
- далее установим необходимые значения PSC, CNT и ARR: у нас таймер должен считать до 100 мс, 
то есть прерывание по переполнению должно происходить каждые 100 мс. 
Чтобы получить такую частоту установим значение prescaler, равное 7999, то есть таймер будет 
увеличивать значение в счётчике на единицу каждую миллисекунду. 
Нам нужно досчитать до 100, чтобы сгененровать переполнение (установим ARR равное 99). 
Начинаем считать с нуля, поэтому устанавливаем CNT равное 0; 
- . 

Полный код программы представлен ниже: 
```
#include "rccregisters.hpp"
#include "gpiocregisters.hpp"
#include "gpioaregisters.hpp"
#include "tim2registers.hpp"

auto delay_100ms()
{
  TIM2::CR1::URS::OverflowEvent::Set();
  
  TIM2::PSC::Set(8000U);
  TIM2::ARR::Write(100U);
  TIM2::CNT::Write(0U);
  
  TIM2::SR::UIF::NoInterruptPending::Set();

  TIM2::CR1::CEN::Enable::Set();
  while(TIM2::SR::UIF::InterruptPending::IsSet()); 
  TIM2::CR1::CEN::Disable::Set();

  TIM2::SR::UIF::NoInterruptPending::Set();
}

int main()
{
  const unsigned int ButPeriod = 100U; 
  unsigned int LedsPeriod = 500U;       // Initial period of LED blinking
  unsigned int counter = 0;             // Counts how much ms past since last LEDs toggling
  bool isCurrentlyOn = 0;
  
  RCC::CR::HSEON::On::Set();
  while(!RCC::CR::HSERDY::Ready::IsSet());

  RCC::CFGR::SW::Hse::Set();
  while(!RCC::CFGR::SWS::Hse::IsSet());
  
  RCC::APB1ENR::TIM2EN::Enable::Set();
  
  RCC::AHB1ENR::GPIOCEN::Enable::Set();
  RCC::AHB1ENR::GPIOAEN::Enable::Set();
  GPIOC::MODER::MODER13::Input::Set();
  GPIOC::MODER::MODER5::Output::Set();
  GPIOA::MODER::MODER5::Output::Set();
  GPIOC::MODER::MODER9::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();

  while(1)
  {
    delay_100ms();
    
    counter += ButPeriod;

    if(GPIOC::IDR::IDR13::Low::IsSet())
    {
      LedsPeriod += ButPeriod;
      counter = 0U;
    }
    
    if(counter >= LedsPeriod)
    {
      if(!isCurrentlyOn)
      {
        GPIOC::BSRR::BS8::High::Write();
        GPIOC::BSRR::BS9::High::Write();
        GPIOC::BSRR::BS5::High::Write();
        GPIOA::BSRR::BS5::High::Write();
        isCurrentlyOn = 1;
      }
      else
      {
        GPIOC::BSRR::BR9::Low::Write();
        GPIOC::BSRR::BR8::Low::Write();
        GPIOC::BSRR::BR5::Low::Write();
        GPIOA::BSRR::BR5::Low::Write();
        isCurrentlyOn = 0;
      }
      
      counter = 0;
    }
  }
  
  return 1;
}
```