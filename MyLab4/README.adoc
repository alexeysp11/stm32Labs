= Lab4

== Задание 

Сделать программу, которая при нажатии кнопки UserButton на отладочной плате 
http://www.waveshare.com/xnucleo-F411RE.htm меняет состояние всех 4 светодидов. 

1. Тактирование производится от PLL на частоте 10 Мгц.
2. По нажатию кнопки поменять состояние всех 4 светодиодов на противоположные
3. Нажатие кнопки определяется по отпусканию кнопки, т.е. нужно определить, что кнопка прижата, 
и дождаться пока она будет отжата - это будет будет означать, что кнопка нажата.

== Выполнение задания

Сначала включим внешний источник HSE, затем нужно дождаться момента, когда он стабилизируется: 
```
RCC::CR::HSEON::On::Set();
while(!RCC::CR::HSERDY::Ready::IsSet());
``` 

Переключим на выбранный источник системную частоту.Дождемся переключения:
```
RCC::CFGR::SW::Hse::Set();
while(!RCC::CFGR::SWS::Hse::IsSet());
```

Отключим внутренний источник HSI и переключим PLL на HSE с помощью регистра PLLCFGR: 
```
RCC::CR::HSION::Off::Set();
RCC::PLLCFGR::PLLSRC::HseSource::Set();
```

Далее необходимо установить нужную частоту. Для этого необходима схема тактирования 
микроконроллера: 

image:https://github.com/alexeysp11/stm32Labs/blob/master/MyLab3/img/ClockTree_stm32f411.png[]

Далее можно начать установку частоты: 
```
// Set VCO equal to 2 MHz => HSE / 4 = 8'000'000 / 4 
RCC::PLLCFGR::PLLM0::Set(4U);

// Set VCC Output equal to 128 MHz => VCO * 64 = 2'000'000 * 64
RCC::PLLCFGR::PLLN0::Set(64U);

// Set PLL Output equal to 32 Mhz => VCC / 4 = 128'000'000 / 4
RCC::PLLCFGR::PLLP0::Pllp4::Set();
```

Активируем PLL и ждем, пока PLL не станет заблокированным: 
```
RCC::CR::PLLON::On::Set();
while(RCC::CR::PLLRDY::Unсlocked::IsSet());
```

Затем переключаем системный источник на полученную частоту и дожидаемся, пока системная 
частота переключится на наш источник. 
```
RCC::CFGR::SW::Pll::Set();
while(!RCC::CFGR::SWS::Pll::IsSet());
```

Настроим порты для светодидов на выход, а порт для кнопки - на вход: 
```
RCC::AHB1ENR::GPIOCEN::Enable::Set();
RCC::AHB1ENR::GPIOAEN::Enable::Set();
GPIOC::MODER::MODER13::Input::Set();
GPIOC::MODER::MODER5::Output::Set();
GPIOC::MODER::MODER8::Output::Set();
GPIOC::MODER::MODER9::Output::Set();
GPIOA::MODER::MODER5::Output::Set();
```

С помощью булевой переменной `isPressed` можно контролировать то, нажата ли кнопка для того, 
чтобы включить светодиоды, или для того, чтобы их выключить: 
```
bool isPressed = false;
while(1)
{
if(GPIOC::IDR::IDR13::Low::IsSet() && isPressed)
{
  isPressed = false;
  
  if(GPIOC::ODR::ODR5::Low::IsSet())
  {
    GPIOC::BSRR::BS5::High::Write();
    GPIOC::BSRR::BS9::High::Write();
    GPIOC::BSRR::BS8::High::Write();
    GPIOA::BSRR::BS5::High::Write();
  }
  else
  {
    GPIOC::BSRR::BR5::Low::Write();
    GPIOC::BSRR::BR9::Low::Write();
    GPIOC::BSRR::BR8::Low::Write();
    GPIOA::BSRR::BR5::Low::Write();
  }
}

if(GPIOC::IDR::IDR13::High::IsSet())
  isPressed = true;
}
```

Полный код программы представлен ниже: 
```
#include "rccregisters.hpp"
#include "gpiocregisters.hpp"
#include <iostream>
#include "gpioaregisters.hpp"

void LEDsToggle()
{
  if(GPIOC::ODR::ODR5::Low::IsSet())
  {
    GPIOC::BSRR::BS5::High::Write();
    GPIOC::BSRR::BS9::High::Write();
    GPIOC::BSRR::BS8::High::Write();
    GPIOA::BSRR::BS5::High::Write();
  }
  else
  {
    GPIOC::BSRR::BR5::Low::Write();
    GPIOC::BSRR::BR9::Low::Write();
    GPIOC::BSRR::BR8::Low::Write();
    GPIOA::BSRR::BR5::Low::Write();
  }
}

int main()
{
  RCC::CR::HSEON::On::Set();
  while(!RCC::CR::HSERDY::Ready::IsSet());

  RCC::CFGR::SW::Hse::Set();
  while(!RCC::CFGR::SWS::Hse::IsSet());
  
  RCC::CR::HSION::Off::Set();

  RCC::PLLCFGR::PLLSRC::HseSource::Set();

  RCC::PLLCFGR::PLLM0::Set(4U);
  RCC::PLLCFGR::PLLN0::Set(50U);
  RCC::PLLCFGR::PLLP0::Pllp6::Set();

  RCC::CR::PLLON::On::Set();

  while(RCC::CR::PLLRDY::Unclocked::IsSet());

  RCC::CFGR::SW::Pll::Set();
  while(!RCC::CFGR::SWS::Pll::IsSet());

  RCC::AHB1ENR::GPIOCEN::Enable::Set();
  RCC::AHB1ENR::GPIOAEN::Enable::Set();
  GPIOC::MODER::MODER13::Input::Set();
  GPIOC::MODER::MODER5::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();
  GPIOC::MODER::MODER9::Output::Set();
  GPIOA::MODER::MODER5::Output::Set();
  
  bool isPressed = false;
  while(1)
  {
    if(GPIOC::IDR::IDR13::Low::IsSet() && isPressed)
    {
      isPressed = false;
      LEDsToggle();
    }
    
    if(GPIOC::IDR::IDR13::High::IsSet())
      isPressed = true;
  }

  return 1 ;
}
```

Стоит заметить, что в полном представлении кода программы часть кода: 
```
if(GPIOC::ODR::ODR5::Low::IsSet())
{
GPIOC::BSRR::BS5::High::Write();
GPIOC::BSRR::BS9::High::Write();
GPIOC::BSRR::BS8::High::Write();
GPIOA::BSRR::BS5::High::Write();
}
else
{
GPIOC::BSRR::BR5::Low::Write();
GPIOC::BSRR::BR9::Low::Write();
GPIOC::BSRR::BR8::Low::Write();
GPIOA::BSRR::BR5::Low::Write();
}
```
выделена в отдельную функцию `LEDsToggle()`, переключающей светодиоды из выключенного состояния
во включенное и наоборот. 
Это сделано для того, чтобы было удобнее читать код функции `main()`. 
